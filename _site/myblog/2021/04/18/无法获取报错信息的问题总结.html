<p>这次“无法获取报错信息”的问题，经过排查总结，是由 Promise 对象使用不当引起的，因此我们先回顾一下 Promise 对象的使用。</p>

<h1 id="promise对象的使用">Promise对象的使用</h1>

<h2 id="promise对象">Promise对象</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创造Promise对象实例</span>
<span class="kd">const</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ... some code</span>
	<span class="c1">// 在内部设定异步操作成功/失败的判断条件</span>
  <span class="k">if</span> <span class="p">(</span><span class="cm">/* 异步操作成功 */</span><span class="p">){</span>
    <span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">reject</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div>

<h2 id="then方法">then()方法</h2>

<p>调用<code class="language-plaintext highlighter-rouge">resolve</code>或<code class="language-plaintext highlighter-rouge">reject</code>以后，Promise 的使命就完成了，后继操作应该放到<code class="language-plaintext highlighter-rouge">then</code>方法里面。我们用<code class="language-plaintext highlighter-rouge">then</code>指定异步操作成功为<code class="language-plaintext highlighter-rouge">resolved</code>状态和失败<code class="language-plaintext highlighter-rouge">rejected</code>状态的回调函数。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// success</span>
<span class="p">},</span> <span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// failure</span>
<span class="p">});</span>
</code></pre></div></div>

<p>这里的<code class="language-plaintext highlighter-rouge">value</code>和<code class="language-plaintext highlighter-rouge">error</code>其实是同一个东西，都是<code class="language-plaintext highlighter-rouge">Promise</code>对象传出的值。只是如果操作成功，值就会被传给第一个回调函数；操作失败，值会被传给第二个回调函数。</p>

<h2 id="catch方法">catch()方法</h2>

<p>如果异步操作抛出错误，状态就会变为<code class="language-plaintext highlighter-rouge">rejected</code>，就会调用<code class="language-plaintext highlighter-rouge">catch()</code>方法指定的回调函数，处理这个错误。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">promise</span>
<span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{},</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{})</span>
<span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">error</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{})</span>
</code></pre></div></div>

<p>既然可以在<code class="language-plaintext highlighter-rouge">then</code>中指定操作失败的回调函数（<code class="language-plaintext highlighter-rouge">then</code>的第二个参数），那么为什么又需要<code class="language-plaintext highlighter-rouge">catch</code>呢？</p>

<p><code class="language-plaintext highlighter-rouge">reject()</code>方法的作用，其实就等同于抛出错误。一般来说，我们不在<code class="language-plaintext highlighter-rouge">then()</code>方法里面定义 Reject 状态的回调函数（即<code class="language-plaintext highlighter-rouge">then</code>的第二个参数），而总是使用<code class="language-plaintext highlighter-rouge">catch</code>方法。</p>

<p>并且，<code class="language-plaintext highlighter-rouge">catch</code>还有另外一个作用：它不仅能捕获<code class="language-plaintext highlighter-rouge">Promise</code>的错误，也能捕获<code class="language-plaintext highlighter-rouge">then</code>的错误。如果没有使用<code class="language-plaintext highlighter-rouge">catch()</code>方法指定错误处理的回调函数，<code class="language-plaintext highlighter-rouge">Promise对象</code>抛出的错误不会传递到外层代码，即不会有任何反应。</p>

<h2 id="then的回调函数">then()的回调函数</h2>

<p><code class="language-plaintext highlighter-rouge">then()</code>接受的两个回调函数，是可选的，即你可以不设置回调函数。如果不设置回调函数，会发生什么呢？用我们自己的代码举例：</p>

<ul>
  <li>不使用<code class="language-plaintext highlighter-rouge">then</code>设置回调函数</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// request.js</span>
<span class="kd">const</span> <span class="nx">request</span> <span class="o">=</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
	<span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// ... some code</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">code</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">res</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">code</span> <span class="o">==</span> <span class="mi">200</span><span class="p">)</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span>
    <span class="k">else</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">};</span>
<span class="c1">// app.js</span>
<span class="k">async</span> <span class="nx">globalRequest</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">requestFunc</span><span class="p">.</span><span class="nx">request</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
  <span class="c1">// 原本应接着写.then(()=&gt;{})</span>
 <span class="p">}</span>
</code></pre></div></div>

<p>结果是<code class="language-plaintext highlighter-rouge">result</code>即为<code class="language-plaintext highlighter-rouge">resolve(res.data)</code>中拿到的<code class="language-plaintext highlighter-rouge">res.data</code>，这意味着，我们不指定回调函数时，会默认返回<code class="language-plaintext highlighter-rouge">resolve()</code>拿到的值。</p>

<ul>
  <li>设置<code class="language-plaintext highlighter-rouge">then</code>中Resolved状态的回调函数（即第一个参数）</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="nx">globalRequest</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">requestFunc</span><span class="p">.</span><span class="nx">request</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span>
      <span class="c1">// 只打印拿到的值，不return value</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
    <span class="p">})</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>结果便是打印了<code class="language-plaintext highlighter-rouge">res.data</code>，<code class="language-plaintext highlighter-rouge">result</code>为<code class="language-plaintext highlighter-rouge">undefined</code>，因为我们没有将值返回。</p>

<ul>
  <li>不设置<code class="language-plaintext highlighter-rouge">then</code>中Rejected状态的回调函数（即第二个参数）</li>
</ul>

<p>代码同上，异步操作成功，不会报错；异步操作失败，由于没有对<code class="language-plaintext highlighter-rouge">reject()</code>做任何后续处理，所以外部也接受不到任何信息。</p>

<h1 id="问题代码复现">问题代码复现</h1>

<ol>
  <li>我们在<code class="language-plaintext highlighter-rouge">request.js</code>中创造了Promise对象实例，并根据返回的状态码来判定异步操作是否成功。</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">request</span> <span class="o">=</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
	<span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
		<span class="nx">wx</span><span class="p">.</span><span class="nx">request</span><span class="p">({</span>
			<span class="c1">// ... some code</span>
			<span class="nx">success</span> <span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">code</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">res</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">code</span> <span class="o">==</span> <span class="mi">200</span><span class="p">)</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span>
					<span class="k">else</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span>
				<span class="p">}</span>
		<span class="p">})</span>
	<span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>我们在<code class="language-plaintext highlighter-rouge">app.js</code>中拿到<code class="language-plaintext highlighter-rouge">request</code>返回的值。</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="nx">globalRequest</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">requestFunc</span><span class="p">.</span><span class="nx">request</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="c1">// ... some code</span>
		<span class="k">if</span> <span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">code</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">res</span><span class="p">.</span><span class="nx">code</span> <span class="o">!=</span> <span class="mi">200</span><span class="p">){</span> 
    <span class="c1">// ... some code</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>所有请求成功（<code class="language-plaintext highlighter-rouge">res.data.code === 0 || res.data.code == 200</code>）的情况下，<code class="language-plaintext highlighter-rouge">res.data</code>都会被赋值给<code class="language-plaintext highlighter-rouge">app.js</code>中的<code class="language-plaintext highlighter-rouge">result</code>。（未指定回调函数时，默认返回<code class="language-plaintext highlighter-rouge">resolve()</code>拿到的值）。</p>

<p>在<code class="language-plaintext highlighter-rouge">app.js</code>中，根本不会存在<code class="language-plaintext highlighter-rouge">res.code != 0</code>或是<code class="language-plaintext highlighter-rouge">res.code ！= 200</code>的情况，因为这种情况已经在<code class="language-plaintext highlighter-rouge">request.js</code>中被判定为异步操作失败而将错误信息传给<code class="language-plaintext highlighter-rouge">reject()</code>了。</p>

<p>为什么单页面中拿不到报错信息？因为我们没有通过<code class="language-plaintext highlighter-rouge">catch()</code>去捕获及处理错误信息。</p>

<h1 id="解决方法">解决方法</h1>

<p>要捕获错误信息，并作出相应处理，就要使用<code class="language-plaintext highlighter-rouge">catch()</code>方法。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">async</span> <span class="nx">globalRequest</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">requestFunc</span><span class="p">.</span><span class="nx">request</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
    <span class="c1">//  使用catch()方法捕获错误</span>
    <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">error</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
 		<span class="c1">// ... 作出相应的处理</span>
      <span class="p">})</span>
    <span class="p">})</span>
    <span class="k">return</span> <span class="nx">result</span>
  <span class="p">}</span>
</code></pre></div></div>

<h1 id="参考阅读">参考阅读</h1>

